---
title: 针对于2025年暑期实习过程中的一些问题的总结
date: 2025-06-29
tags:
  - 实习
---
尽量做到每日总结，一边是进步，一边是积累，一边是复盘。
---

#### 6.27

##### 问题1：padding导致内容溢出。解决方案：box-sizing:border-box
详情：https://juejin.cn/post/7374265502669783074?searchId=202506290833116992C251783B98FE8AAF

问题本质是标准盒子模型和怪异盒子模型，其中标准盒子模型中box-sizing:content-box，其中的总的宽度和高度仅由height和width控制，

一个元素的 `width` 为 200px，`padding - left` 为 20px，`padding - right` 为 30px，`border - left - width` 为 5px，`border - right - width` 为 10px，`box - sizing` 设置为 `content - box`，则元素的实际总宽度为 200px + 20px + 30px + 5px + 10px = 265px，而元素的 `width` 属性值仍为 200px。

当设置为 `border - box` 时，元素的总宽度和高度等于 `width` 和 `height` 属性的值加上内边距和边框的宽度。

假设一个元素的 `width` 为 200px，`padding - left` 为 20px，`padding - right` 为 30px，`border - left - width` 为 5px，`border - right - width` 为 10px，`box - sizing` 设置为 `border - box`，则元素的总宽度为 200px + 20px + 30px + 5px + 10px = 265px。

##### 问题2：有关position定位问题：relative absolute fixed sticky

详情：https://juejin.cn/post/7438824467905986569?searchId=202506290845454706298DBBD36212FA7A

其中大致可以总结为：

relative: 当前元素的代码块所占空间仍被保留，可以用过top,bottom,left,right进行控制位置

absolute: 如果当前元素的父元素有relative的属性，则是相对于父组件确定top,bottom,left,right，如果父组件没有设置relative属性，则是相对于这个屏幕的设置top,bottom,left,right

fix: 当前元素的代码块不被保留，只用top,bottom,left,right确认当前代码块的位置

sticky: 可以简单理解为在父组件为overflow状态下的fix,详情可看https://juejin.cn/post/7498536086395879451?searchId=202506290921215994F092FB16AF00FAF1


#### 6.28
##### 总结1：针对页面布局时候的一些开发规范
在开发页面的时候，一定要在看到设计搞得时候脑海中浮现出如何去划分盒子模型，要有先整体后局部的开发思路。尽量简化div的使用，在不是必要的情况下不用过度使用div，导致样式逻辑后续开发会很复杂，在设置padding的时候要注意box-sizing: border-box的使用。在完成一个页面开发之后进行抽离components，尽量在页面中做到

~~~html
<template>
	<div>
    	<A></A>
        <B></B>
        <C></C>
    </div>
	<div>
        <D></D>
    </div>
</template>
~~~

这样进行排版，在写css样式的时候尽量做到

~~~css
.a{
    width:100px;
    height:100px;
    margin:10px;
    padding:10px;
    box-sizing:border-box;
    position:relative;
    backgroud-color:#aaa;
}
~~~
大致可以理解为：先确定宽高，后确定边距，然后考虑位置信息，最后考虑背景图，border等属性。

#### 6.30

任务1：完成评论列表的开发：其中包括头像，姓名，内容，图片，点赞，以及回复列表，在列出子组件的时候，由于子组件与父组件高度重复，但是又有一些简单的属性不一致，所以没有抽离组件，而是在父组件的基础上修改简单的样式作为子组件

- 1 父组件封装的时候一些难点：

  - 1 分页查询 四个字段：page,pageSize,hasMore,loading分别代表当前页码，每页显示数量，还有没有更多，是否在加载

         ```js
         const loadPagedComments = () => {
           if (state.loading || !state.hasMore) return
           state.loading = true
           const start = (state.page - 1) * state.pageSize
           const end = state.page * state.pageSize
           const newPageComments = state.commentList.slice(start, end)
           if (newPageComments.length > 0) {
             state.displayComments = [...state.displayComments, ...newPageComments]
             state.page++
             state.hasMore = end < state.commentList.length
           } else {
             state.hasMore = false
           }
           state.loading = false
         }
                                                           
                                                          onReachBottom(() => {
           if (state.hasMore && !state.loading) {
             loadPagedComments()
           }
         })
         ```

  处理分页逻辑：页面触底的时候，当还有更多并且不在加载中的时候，触发加载更多的函数。其中函数内容包括：1. 判断是否还有新内容，2. 加载新的数据，3. 旧数据和新数据合并，4. 修改页数和加载状态。	

- 2 子组件封装的难点

  - 1 加载更多

    条件：当前评论回复的数量>已经加载的评论数量，此时显示展示更多按钮

    ```js
    <secondComment
    :showLoadMore="(item.replyCount && item.replyList.length) > (item.loadedReplies?.length)" />
    ```

  - 2 分页

    分页逻辑同父组件一样，但是比父组件多一个检索的操作

    ~~~js
     const parentComment = state.commentList.find(item => item.id === commentId)
    ~~~

任务2：针对评论图片组件的二次开发

- 难点1：针对不同个数的图片有不同的展示方案

```vue
 <image
            v-for="(item, index) in props.list"
            :key="index"
            :src="item.url + '?image_process=resize,w_180'"
            :mode="layoutType === 'single' ? 'widthFix' : 'aspectFill'"
            :style="getImageStyle(item, index)"
            lazy-load
        ></image>
```

​	针对不同的图片，动态设置src和mode的值，其中核心逻辑

```js
// 确定布局类型
    const layoutType = computed(() => {
        if (props.list.length === 1) return 'single'
        if (props.list.length === 4) return 'grid4'
        return 'normal' // 2-3张或5张以上
    })

    // 容器样式
    const containerStyle = computed(() => {
        let baseStyle = props.customStyle || ''

        if (layoutType.value === 'single') {
            return `${baseStyle} display: flex; justify-content: flex-start; flex-wrap: nowrap;`
        }

        if (layoutType.value === 'grid4') {
            return `${baseStyle} max-width: calc(${props.width} * 2 + 16rpx); display: flex; flex-wrap: wrap;`
        }

        return baseStyle
    })

    // 根据不同布局类型设置图片样式
    const getImageStyle = (item, index) => {
        // 单图模式：不强制正方形
        if (layoutType.value === 'single') {
            return `max-width: 240rpx; max-height: 500rpx; border-radius: ${props.radius};`
        }

        // 四宫格模式
        if (layoutType.value === 'grid4') {
            const isEven = (index + 1) % 2 === 0
            return `width: ${props.width}; height: ${props.height}; border-radius: ${props.radius};
                ${isEven ? 'margin-bottom: 16rpx;' : 'margin-bottom: 16rpx; margin-right: 16rpx;'}`
        }

        // 普通网格模式
        const isThird = (index + 1) % 3 === 0
        return `width: ${props.width}; height: ${props.height}; border-radius: ${props.radius};
            ${isThird ? 'margin-bottom: 16rpx;' : 'margin-bottom: 16rpx; margin-right: 16rpx;'}`
    }
```

​	可以做成四宫格核心在

```js
 return `${baseStyle} display: flex; justify-content: flex-start; flex-wrap: nowrap;`
```

​	设置最大宽度为两个图片加上margin的宽度之后换行。
