---
title: 工作小结
date: 2025-08-04
tags:
  - 工作小结
---
近期一共实现了四大板块，帖子详情页面、选人页面、圈子页面、腾讯IM接入聊天
---

### 帖子详情页面
从上往下将帖子可以分为以下部分，顶部tabbar，帖子详情图片swiper，标题内容信息展示，匹配模式（单人/多人），评论展示，底部对于帖子参与状态操作按钮，底部弹窗，分享当前帖子弹窗。针对总体页面，需要注意的一些地方：设定一个pageFinished，设定骨架屏，当页面数据还没有获取完毕的时候正常展示骨架屏，pageFinished为true的时候展示页面数据。在设置页面的时候，考虑兜底情况：例如帖子被删除了，就展示自定义Empty组件
#### 顶部tabbar

对于顶部tabBar主要是有两个属性 backgroundColor=transparent，和fixed属性，一个是保证tabbar透明，一个是固定在页面的最上方。在uni-nav-bar中使用插槽，自定义组件内容例如可以插入头像，名称等，通过与left-width搭配

#### 图片swiperLine

这是一个自定义的可滑动的图片组件，上方用uv-image进行控制< swiper>< swiper-item>< uv-image>这样来控制，下方通过position去控制下方自定义指示点的位置，props可以传很多自定义参数，list:图片列表，剩下可以参考swiper的一些属性，控制是否展示指示点，展示的指示点的位置，大小，是否可以自动轮播，是否可以预览大图等等

#### 评论部分

```text
CommentSection (外层容器)
├── CommentList (评论列表)
│   ├── secondComment (二级评论)
│   └── 评论项 (头像、内容、操作)
└── CommentInput (输入框)
```

评论部分有以下核心操作

1. lastId做游标分页，每次获取后端数据的时候需要记录commentList[length-1].id的值
2. hasMore根据后端返回的数据动态计算是否还有下一页的顺序，对获取评论接口进行控制
3. topId和parentId进行评论级别控制：其中如果topId = parentId = -1 则代表是发布新评论（父级评论）如果是topId=parentId!=-1则代表的是二级评论，其中等于的值为父评论的id。例如父评论的id为10，则topId=parentId=10。多级评论，其中topId的值为顶级评论的id，parentId为父评论Id，例如顶级评论id为10，回复顶级评论的评论id为11，则该评论topId=10，parentId=11，剩下以此类推，三级四级评论只要保证topId指向顶级评论的id就能实现他们在同一级下
4. 发布评论之后需要在本地做缓存，根据上述的topId和parentId来查找评论，查到之后用unshift插入（保证插入的数据在上方）
5. 乐观更新：点赞的时候先实现UI的更新，之后再调用接口，成功则不处理，失败了再将UI更新效果返回
6. uni.$emit和uni.$on和uni.$off，在commentSection中，消息传递层级过多，需要经过input->section->commentList->secondComment这些组件进行传递，所以当发送评论的时候，完全可以使用uni.$emit来进行传递，这里需要注意当使用uni.$on在离开页面的时候记得用uni.$off销毁事件
7. 做分页时候，对于获取评论接口用参数reset控制，如果为true则第一次加载，默认页码为1，当触底的时候，参数reset为true，则加载当前page+1页面的数据，之后进行[...A,...B]返回数据

~~~text
用户操作 → 本地状态更新 → API调用 → 服务器响应 → 状态同步
    ↓
UI更新 ← 事件通知 ← 数据验证 ← 错误处理
~~~

#### 底部按钮部分

这部分没有什么太多操作，主要是吧所有情况分析到位，当前状态是可以报名，还是不可报名，等等

#### 弹窗部分

这部分主要是通过uv-popup来做的一个底部弹窗，然后通过uv-tabs做两个不同栏目的展示。其中的交互比较复杂的逻辑有以下

1. 当选中帖子之后，如果两个栏目有相同的帖子在另外一个列表也是选中状态，如果在评论组件有这个帖子之后，再次点击弹窗之后该帖子依旧是被选中状态

   处理逻辑：在share-popup中维护一个selectedList，当两个子组件有选中帖子的时候，emit当前选中的item，然后插入到selectList中，同时selectedList和两个不同子组件也要双向绑定，如果被selected之后再次点击通过Id进行查询，将这个id的帖子设置为选中状态

2. 选中帖子到评论区input组件点击弹出popup之后依旧回显

​	处理逻辑，将selectedList传给index，再让Index传给input，因为input中是使用自定义封装的post-input，这里会存储到id，这个	时候也是将index传过来的值和index进行双向绑定，index再与selectedList双向绑定，这样就能做到数据的回显

       3. 难点在于 新增 和 删除 input 选中的帖子和重新选择帖子的时候，如何做到数据的统一，在当前组件实现的思路是，每次新增选中帖子或者减少选中帖子的时候，直接给一个新的selectedList，input中之前缓存的selectedList直接清空，用新选中的帖子进行渲染

#### 分享当前页面

这个主要是用的微信小程序给的API

~~~js
onShareAppMessage(() => {
    return {
        title: '快来加入' + state.detail.title + '组局吧！',
        path: '/pagesDetail/detail/index?id=' + state.detail.id + '&userId=' + userInfo.value.id
    }
})
onShareTimeline(() => {
    return {
        title: '快来加入' + state.detail.title + '组局吧！',
        path: '/pagesDetail/detail/index?id=' + state.detail.id + '&userId=' + userInfo.value.id
    }
})
~~~

这里有一点值得注意的地方就是 这个需要写在父组件，不能写在子组件中，因为 onShareAppMessage onShareTimeline 这两个是页面级别的生命周期钩子，子组件只有组件生命周期，只有“页面”级别的才有页面生命周期

### 选人页面

#### 难点1：针对头像下的三角如何确保一直指向被选中的头像

​	解决方案：将头像和三角放在一个div中，下方三角用css画出来。

```css
.indicator-triangle {
    z-index: 1;
    width: 0;
    height: 0;
    border-left: 15rpx solid transparent;
    border-right: 15rpx solid transparent;
    border-bottom: 15rpx solid #ffd700; 
}
```

​	然后给出v-if，当选中的时候再显示.indicator-triangle属性。

#### 难点2：如何确保点击头像会使得头像居中

​	实现思路：scroll-view如果是左右轮播的时候有一个属性：scroll-left，这里传入一个x坐标的值，就能将其定位到屏幕左侧距离x的位置。

具体内容：使用const screenWidthPx= uni.getSystemInfoSync().windowWidth，这样可以获取屏幕的px的值，这里需要考虑在页面使用rpx作为计量单位，需要使用const rpxRatio = screenWidthPx / 750 来计算rpx的比例。然后需要考虑在当前页面的基础之上，应该滚动多少距离，也就是对应的idealPosition的值，cothnst idealPosition = index * avatarWidthPx - screenWidthPx / 2 + avatarWidthPx / 2 这个可以这样理解，当前页面所在的位置是前面所有Index的宽度之和，也就是index * avatarWidthPx，想让图片实现居中，就需要滚动index * avatarWidthPx - screenWidthPx / 2这个位置，但是这样会导致是头像组件的最左侧在中间，此时需要再滚动头像组件的一半内容，此时就可以做到头像正好在页面的正中央

```js
const scrollToIndex = (index) => {
    nextTick(() => {
        // 计算理想的滚动位置（使选中项居中）
        const idealPosition = index * avatarWidthPx - screenWidthPx / 2 + avatarWidthPx / 2

        // 确保不滚动超出范围
        const maxScroll = containerWidth.value - screenWidthPx
        scrollLeft.value = Math.max(0, Math.min(idealPosition, maxScroll))
    })
}
```

```text
scrollLeft设置与头像居中计算的详细解析
在selectperson.vue文件中，每个计算步骤对应的变量名如下：
案例：index = 7
1. 基本参数
每个头像宽度：avatarWidthPx = avatarWithGapRpx * rpxRatio（
屏幕宽度：screenWidthPx = uni.getSystemInfoSync().windowWidth
目标索引：index = 7 (假设用户选择了第7个头像)
2. 计算过程
头像左边缘位置计算：
const avatarLeftEdgePosition = index * avatarWidthPx
// 案例中 = 7 * 60 = 420px
屏幕中心点：
const screenCenterPosition = screenWidthPx / 2
// 案例中 = 300 / 2 = 150px
头像中心偏移：
const avatarCenterOffset = avatarWidthPx / 2
// 案例中 = 60 / 2 = 30px
计算理想滚动位置：
const idealPosition = index * avatarWidthPx - screenWidthPx / 2 + avatarWidthPx / 2
// 案例中 = 420px - 150px + 30px = 300px
3. 设置scrollLeft值
当我们设置scrollLeft.value = 300px时：
scrollLeft.value = Math.max(0, Math.min(idealPosition, maxScroll))
这个操作是告诉滚动容器从左边界开始滚动300px，这是一个UI渲染指令，不是再次进行数学计算。
4. UI渲染结果解析
当滚动容器向左滚动300px后：
头像左边缘在屏幕上的位置 = 头像在内容中的位置 - 滚动量
= 420px - 300px = 120px  // 起始位置avatarLeftEdgePosition的值为420px，滚动了300px还有距离页面左边120px
头像中心在屏幕上的位置 = 头像左边缘在屏幕上的位置 + 头像宽度的一半
= 120px + 30px = 150px（正好是屏幕中心screenWidthPx/2）
```



### 圈子界面

这里主要是针对mescroll-body的使用操作

```text
<template>
  <mescroll-body
    :down="{ auto: false }"  //下拉刷新配置（如 auto: false 表示不自动刷新）
    :up="{ textNoMore: '没有更多了', empty: { use: true, tip: '暂无数据' } }" //上拉加载配置textNoMore、empty 等
    @init="mescrollInit" mescroll 初始化时回调，获取 mescroll 实例
    @down="reload" 下拉刷新回调
    @up="load" 上拉加载回调
  >
    <!-- 列表内容 -->
  </mescroll-body>
</template>
```

其中针对这些参数，后续需要做的一些处理：

处理模板

~~~vue
<template>
  <mescroll-body
    :down="{ auto: false }"
    :up="{ textNoMore: '没有更多了', empty: { use: true, tip: '暂无数据' } }"
    @init="mescrollInit"
    @down="reload"
    @up="load"
  >
  </mescroll-body>
</template>

<script setup>
const state = reactive({
  mescroll: null,  // mescroll实例
  list: [],  // 获取的数据列表
  page: { num: 1, size: 10 }, // 分页参数
  hasNext: true  // 是否还有更多
})

// 初始化实例
const mescrollInit = (mescroll) => { state.mescroll = mescroll }

// 下拉刷新
const reload = async () => {
  state.page.num = 1
  state.hasNext = true
  // ...请求第一页数据
  state.list = data.list
  state.hasNext = data.hasNext
  state.mescroll.endSuccess(data.list.length, data.hasNext)  // 这里需要告诉mescroll 是否结束了
}

// 加载更多
const load = async () => {
  // 结束处理
  if (!state.hasNext) {
    state.mescroll.endSuccess(0, false)
    return
  }
  state.page.num++
  // ...请求下一页数据
  state.list = [...state.list, ...data.list]
  state.hasNext = data.hasNext
  state.mescroll.endSuccess(data.list.length, data.hasNext)
}

// 如果在有些时候 @up="load" 无效的时候可以使用这个强制刷新
onReachBottom(() => {
    state.mescroll.triggerUpScroll()
})
// 有些情况需要自动上拉刷新
const refresh = () => {
  state.mescroll.triggerDownScroll()
}
</script>
~~~

如果遇到多个子组件都需要下拉刷新，每个页面单独维护reload load pageParams即可，父组件统一维护mescroll即可



#### 腾讯IM

腾讯IM部分没什么太多难点，主要就是查文档 https://cloud.tencent.com/document/product/269/105570 基本所有需求文档中都能实现。有一些需要自定义的实现，在返回的message中有一个CloudCustomData参数接受字符串，可以通过JSON.parse和JSON.stringify自定义内容
